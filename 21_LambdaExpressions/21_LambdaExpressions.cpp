#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

struct Square_Functor {
	void operator() (int x) {
		std::cout << x * x << "; ";
	}
};

template<typename T>
struct Displayer {
	void operator() (const T& data) {
		std::cout << data << "; ";
	}
};

class Multiplier {
private:
	int num;

public:
	Multiplier(int n) : num{ n } {}
	int operator() (int m) const {
		return num * m;
	}
};

void filter_vectors(std::vector<int>& vec, std::function<bool(int)> func) {
	std::cout << "[";
	for (auto i : vec) {
		if (func(i)) {
			std::cout << i << " ";
		}
	}
	std::cout << "]" << std::endl;
}

int main()
{
	std::cout << "\n========================================== LAMBDA EXPRESSIONS =====================================================\n";

	/*******************************************************************
	* FUNCTION OBJECTS IN STL
	*******************************************************************/

	std::cout << "\n------------------------------------------ FUNCTION OBJECTS IN STL ------------------------------------------------\n";

	Square_Functor sf;
	sf(4);
	std::cout << std::endl;

	Displayer<int> d1{};
	d1(100);
	std::cout << std::endl;

	Displayer<std::string> d2;
	d2("Frank");
	std::cout << std::endl;

	std::vector<int> vec1{ 1, 2, 3, 4, 5 };
	std::vector<std::string> vec2{ "Bob", "Joe", "Jack" };

	std::for_each(vec1.begin(), vec1.end(), sf);
	std::cout << std::endl;

	std::for_each(vec1.begin(), vec1.end(), d1);
	std::cout << std::endl;

	std::transform(vec1.begin(), vec1.end(), vec1.begin(), Multiplier(100));
	std::for_each(vec1.begin(), vec1.end(), Displayer<int>());
	std::cout << std::endl;

	std::for_each(vec2.begin(), vec2.end(), Displayer<std::string>());
	std::cout << std::endl;

	/*******************************************************************
	* LAMBDA EXPRESSIONS IN STL
	*******************************************************************/

	std::cout << "\n------------------------------------------ LAMBDA EXPRESSIONS IN STL ----------------------------------------------\n";

	vec1 = { 1,2,3,4,5 };
	std::for_each(vec1.begin(), vec1.end(), [](int x) { std::cout << x * x << "; "; });
	std::cout << std::endl;

	std::for_each(vec1.begin(), vec1.end(), [](int x) {std::cout << x << "; "; });
	std::cout << std::endl;

	std::transform(vec1.begin(), vec1.end(), vec1.begin(), [](int x) { return x * 100; });
	std::for_each(vec1.begin(), vec1.end(), [](int x) { std::cout << x << "; "; });
	std::cout << std::endl;

	std::for_each(vec2.begin(), vec2.end(), [](std::string x) { std::cout << x << "; "; });
	std::cout << std::endl;

	/*******************************************************************
	* STATELESS LAMBDA EXPRESSIONS
	*******************************************************************/

	std::cout << "\n---------------------------------------- STATELESS LAMBDA EXPRESSIONS ---------------------------------------------\n";

	[]() { std::cout << "Hi" << std::endl; }();
	[](int x, int y) { std::cout << x + y << std::endl; }(10, 5);

	auto lambda = [](int x, int y) { std::cout << x + y << std::endl; };
	lambda(10, 10);

	auto lambda2 = [](int& x, int y) {
		std::cout << "x: " << x << " y: " << y << std::endl;
		x = 1000;
		y = 2000;
	};

	int num1{ 100 };
	int num2{ 200 };
	lambda2(num1, num2);
	std::cout << "num1: " << num1 << " num2: " << num2 << std::endl;


	std::vector<int> nums{ 10,20,30,40,50,60,70,80,90,100 };
	filter_vectors(nums, [](int x) { return x > 50; });
	filter_vectors(nums, [](int x) { return x < 30; });
	filter_vectors(nums, [](int x) { return x >= 30 && x <= 60; });

	/*******************************************************************
	* STATEFUL LAMBDA EXPRESSIONS
	* The compiler generate functor with lambda expression with a default ctor and the operator() overriden.
	*******************************************************************/

	std::cout << "\n---------------------------------------- STATEFUL LAMBDA EXPRESSIONS ---------------------------------------------\n";

	int x{ 100 };
	int y{ 200 };
	int z{ 300 };

	auto l1 = [x]() {											// x is passed by value. it's a copy and a const. It cannot be modified.
		std::cout << "copy const x: " << x << std::endl;
	};

	l1();
	std::cout << "original x: " << x << std::endl;

	auto l2 = [x]() mutable {									// "mutable" keyword allows to modify the copy.
		x += 100;
		std::cout << "copy mutable x: " << x << std::endl;
	};

	l2();									
	std::cout << "original x: " << x << std::endl;			
	l2();														// 300. The lambda is not constructed again (the ctor of the functor generated by the compiler), so x is not captured again.
	std::cout << "original x: " << x << std::endl;

	auto l3 = [&x]() {											// Pass by reference. Original x is modified as well.
		x += 100;
		std::cout << "reference x: " << x << std::endl;
	};
	l3();
	std::cout << "original x: " << x << std::endl;

	auto l4 = [=]() mutable {									// "=" capture all variables defined in the scope, IF they're used in the lambda (z is not), and passed them by value by default.
		x += 100;
		y += 50;
		std::cout << "= captured x: " << x << std::endl;
		std::cout << "= captured y: " << y << std::endl;
	};
	l4();

	auto l5 = [&]() {											// "=" capture all variables defined in the scope, IF they're used in the lambda (z is not), and passed them by reference by default.
		x += 100;
		y += 50;
		std::cout << "& captured x: " << x << std::endl;
		std::cout << "& captured y: " << y << std::endl;
	};
	l5();

	auto l6 = [=, &y]() mutable {								// x and z captured by value by default (and mutable), y by reference.	
		x += 100;
		y += 50;
		z += 25;
		std::cout << "= captured x: " << x << std::endl;
		std::cout << "by reference y: " << y << std::endl;
		std::cout << "= captured z: " << z << std::endl;
	};
	l6();

	auto l7 = [&, x]() mutable {								// x and y captured by reference by default, z by value (mutable).	
		x += 100;
		y += 50;
		z += 25;
		std::cout << "by value x: " << x << std::endl;
		std::cout << "& captured y: " << y << std::endl;
		std::cout << "& captured z: " << z << std::endl;
	};
	l7();

	std::cout << "\n========================================== LAMBDA EXPRESSIONS =====================================================\n";

	return 0;
}
